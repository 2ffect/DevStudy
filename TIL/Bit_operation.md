## 비트연산 
### XOR 연산자
- ^ : XOR 연산자, OR 처럼 작동하지만 둘 다 1인 경우는 0
    - 같으면 0 다르면 1
    
### 신기한 XOR
- 어떤 값이던 특정 수로 2회 XOR 하면 원래수로 돌아온다.
- 7070 ^ 1004 = 6258
- 6258 ^ 1004 = 7070

### 비트 연산자
- << (Left Shift) : 특정 수 만큼 비트를 왼쪽으로 밀어낸다.(밀수 없으면 오른쪽에 0을 추가)
- \>> (Right Shift) : 특정 수 만큼 비트를 오른족으로 밀어낸다. (우측 비트들이 제거 됨)
```python
print(bin(0b1101 << 2)) # 0b110100
print(bin(0b1101 >> 2)) # 0b11
```

### 비트연산 응용
1. 1 << n
부분집합의수 = 2 ** n
```python
# 비트연산 응용
arr = [1, 2, 3, 4]
print(1 << len(arr)) # 16
```
2. i & (1 << n)
i의 n번째 비트가 1인지 아닌지 확인 가능 (부분집합 찾기)

### 음수 표현 방법
- 컴퓨터는 음수를 "**2의 보수**"로 관리한다.
- 맨 앞자리 bit(**MSB**)는 음수 or 양수를 구분하는 비트

### 2의 보수
- 각 비트를 뒤집고, 1을 더한다.
ex) 0000 0101 (5) > 1111 1011 (-5)
  - 두 수를 더하면 1 0000 0000
    덧셈 연산 시 over bit는 삭제 -> 0000 0000 (0)

### 2의 보수로 음수를 관리하는 이유
- 뺄셈의 연산 속도를 올릴 수 있으며 +0과 -영을 따로 취급하지 않기 위해

### 신기한 2의 보수
- 2의 보수를 취한 수를, 한번 더 2의 보수를 취하면 원래 값으로 돌아온다.
    - 10001 의 2의 보수
        01110 + 1 = 01111
    - 01111 의 2의 보수
        10000 + 1 = 10001
      
### bitwise NOT(complement) 연산자
- ~ 연산자 : 모든 비트를 반전시킨다.
- 8-bit 일때 ~(0001 1111) 이라면 1110 0000이 된다.

### 파이썬 bitwise Not 연산자 출력 과정
- 4의 경우 0100 (MSB : 양수이기 때문에 0)
- ~4 Not 연산자로 인해 뒤집게 되면 1011 (MSB : 1이니까 음수)
- MSB를 제외한 나머지 bit에 대해 2의 보수를 취한다.
- 011 -> 100 + 1 -> 101
- MSB(1)bit(101) 이므로, -5
- 따라서 ~4 == -5 가 된다.
  
