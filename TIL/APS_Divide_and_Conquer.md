# 분할 정복
## 분할 정복 기법
### 설계전략 
1. 분할(Divide) : 해결할 문제를 여러개의 작은 부분으로 나눈다.
   - 더 이상 나눌 수 없거나, 나눌 필요가 없을때까지
2. 정복(Conquer) : 나눈 작은 문제를 각각 해결한다.
3. 통합(Combine) : (필요하다면) 해결된 해답을 모은다.

### 형식의 예
- Top-down approach

![img.png](Top-down.png)

- 분할 정복의 대표적인 예시코드
```python
# 반으로 나눈다고 가정(재귀호출)
def recur():
   left = recur(left에 필요한 변수)
   right = recur(right에 필요한 변수)
   result = left + right # 병합
```

## 병합 정렬(Merge Sort)
- 여러 개의 정렬된 자료의 집합을 병합하여 한 개의 정렬된 집합으로 만드는 방식
- 분할 정복 알고리즘 활용
   - 자료를 최소 단위 문제까지 나눈 후에 차례대로 정렬하여 최종 결과를 얻어 냄
   - top-down 방식
   
- 시간 복잡도
   -  O(n log n)
   
- 분할 단계 : 전체 자료 집합에 대하여 **최소 크기의 부분집합이 될 때까지** 분할 작업 진행
```python
[69, 10, 30, 2, 16, 8, 31, 22] >> [69], [10], [30], [2], [16], [8], [31], [22]
```

- 병합 단계 : 2개의 부분집합을 정렬하면서 하나의 집합으로 병합
```python
[69], [10], [30], [2], [16], [8], [31], [22]
>>
[10, 69], [2, 30], [8, 16], [22, 31]
>>
[2, 10, 30, 69], [8, 16, 22, 31]
>>
[2, 8, 10, 16, 22, 30, 31, 69]
```

## 퀵 정렬(Quick Sort)
- 주어진 배열을 두 개로 분할하고 각각 정렬한다.
- 병합 정렬과 차이
    1. 퀵 정렬은 분할 시 기준 아이템(pivot item) 중심으로 분할
        - 기준보다 작은 것은 왼편, 큰 것은 오른편에 위치
    2. 퀵 정렬은 병합을 필요로 하지 않는다.
    
- Quick Sort 는 Partitioning 이라는 과정을 반복하면서 평균 시간복잡도 O(n log n)속도라는 빠른 속도로 정렬되는 SOrt
- 시간 복잡도
  - 평균
    O(n log n)
  - 최악
    O(N ** 2)
    
### 파티션
1. 호어 파티션
  - pivot 기준, i, j 를 좌우 끝에서부터 가운데로 이동
2. 로무토 파티션
  - pivot 은 제일 우측, i, j를 왼쪽에서 같이 이동

=> 역순 정렬이 되어있을 때 최악의 성능

## 이진 검색
- 자료의 가운데 잇는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법
    - 목적 키를 찾을 때 까지 이진 검색을 순환적으로 반복 수행함으로써 검색 범위를 반으로 줄여가면서 보다 빠르게 검색을 수행
    
- 이진 검색을 하기 위해서는 자료가 정렬된 상태여야 한다.

