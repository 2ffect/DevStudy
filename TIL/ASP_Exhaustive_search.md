# APS 응용
## 완전 검색
### 1. 반복과 재귀
- 반복과 재귀는 유사한 작업을 수행할 수 있다.
- 반복은 수행하는 작업이 완료될 때 까지 계속 반복
    - 루프 (for, while 구조)
    - 반복문은 코드를 n번 반복시킬 수 있다.
    
- 재귀는 주어진 문제의 해를구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법
    - 재귀호출은 n중 반복문을 만들어 낼 수 있다.
    - 하나의 큰 문제를 해결할 수 있는(해갈하기 쉬운) 더 작은 문제로 쪼개고 결과들을 결합한다.
    
#### 재귀 호출 구성 특징
1. 종료 조건 (기저 조건 - base case) 
2. 재귀 호출 전 시행해야할 로직
3. 다음 재귀 호출(매개 변수를 변경하면서 전달)
4. 돌아 오면서 해야 할 로직 !! 

### 2. 순열
- 서로 다른 N 개에서, R 개를 중복없이, 순서를 고려하여 나열하는 것
#### 중복 순열
- 서로 다른 N 개에서, R 개를 중복을 허용하고, 순서를 고려하여 나열하는 것
#### 중복 순열 구현 원리
1. 재귀 호출을 할 때 마다, 이동 경로를 남긴다.
2. 가장 마지막 레벨에 도착했을 때, 이동 경로를 출력한다.
```python
# [0, 1, 2] 3개의 카드가 존재
# 2개를 뽑을 예정
# 중복 순열 코드

# 뽑은 카드를 저장
path = []

# cnt = 재귀 호출마다 누적되어 전달되어야 하는 값. (매개변수로 사용)
def recur(cnt):
    # 카드를 2개 뽑으면 종료
    if cnt == 3:
        # 종료 시 해야할 로직들을 작성
        print(*path)
        return

    # 1. 1개의 카드를 뽑는다.
    for num in range(1, 7):
        path.append(num)
        # 다음 재귀 호출
        recur(cnt + 1)
        # 맨 마지막꺼 하나 뺀다.
        path.pop()

# 처음 호출 할 때 시점이므로 초기값을 전달하여 시작
recur(0)
```

#### 중복을 취급하지 않는 순열 구현 원리
1. 중복 순열 코드를 작성한다.
2. 중복을 제거하는 코드를 추가한다.

#### 중복을 제거하는 원리
- 전역 리스트를 사용하면 이미 선택했던 숫자인지 아닌지 구분할 수 있다.
- 이를 used 배열 또는 visited 배열 이라고 한다.
```python
# 뽑은 카드를 저장
path = []
# 숫자 사용 여부를 기록
used = [False] * 7

# 숫자 범위가 매우 큰 경우
# dict, set 등의 자료구조로 해결

# cnt = 재귀 호출마다 누적되어 전달되어야 하는 값. (매개변수로 사용)
def recur(cnt):
    # 카드를 2개 뽑으면 종료
    if cnt == 3:
        # 종료 시 해야할 로직들을 작성
        print(*path)
        return

    # 1. 1개의 카드를 뽑는다.
    for num in range(1, 7):
        # 이미 num을 봅았다면 뽑지마라.
        # == num을 뽑지 않았을 때 뽑아라.
        if used[num] is True:
            continue

        used[num] = True
        path.append(num)
        # 다음 재귀 호출
        recur(cnt + 1)
        # 맨 마지막꺼 하나 뺀다.
        path.pop()
        used[num] = False


# 처음 호출 할 때 시점이므로 초기값을 전달하여 시작
recur(0)
```

### 3. 완전 탐색
- 완전탐색 (== Brute-Force, 부루트포스 알고리즘 이라고 한다.)
  -  모든 가능한 경우를 모두 시도하여 정답을 찾아내는 알고리즘
  
