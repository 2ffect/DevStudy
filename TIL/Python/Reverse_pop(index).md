# Pop(index)
- 반복문을 활용하여 pop(index)로 특정 인덱스를 제거 할 경우 반복이 될 때 리스트의 길이가 달라지면서 인덱스에 변화가 발생하게 된다. 
- 그럴경우 예상과 다르게 다른 요소가 제거되면서 결과값이 의도와 다르게 출력된다.
- 이 문제를 해결하기 위해 pop(index)에 대해 알아보게 됐다. (문제가 안 풀려서 짜증이 10중 8정도 났다. 머리가 아직 많이 나쁜가보다)

## 해결법
- 우선 해결법을 먼저 얘기하자면 리스트의 인덱스를 역순으로 제거하면 리스트의 길이가 짧아지더라도 고유 인덱스는 변화하지 않으므로 반복적으로 제거할 때 영향을 주지 않는다는 뜻이다. 이해는 됐는데 글로 설명하려니 이해가 되지 않게 써진다. 연휴 끝나면 강사님한테 물어봐야겠다.

## 풀이과정

- 문제는 주어진 리스트에서 pop을 활용해 홀수값을 제거하고, extend를 활용해 짝수 리스트를 반환하는 함수를 만드는 것이었다.
- 우선 제출한 코드를 먼저 보여주자면 아래와 같다.
```py
def even_elements(my_list):
    new_list = []
    for num in range(len(my_list) -1, -1, -1):
        if my_list[num] % 2 == 0:
            new_list.extend([my_list.pop(num)])
    
    new_list.sort()

    return new_list

my_list = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
result = even_elements(my_list)
print(result) # [2, 4, 6, 8, 10]
```

1. 역순으로 순화하는 이유
 -  for num in range(len(my_list) - 1, -1, -1) 구문을 사용하여 리스트의 끝에서부터 첫 번째 요소까지 거꾸로 순회한다. 역순으로 순회하는 이유는, pop을 사용하여 요소를 제거할 때, 뒤에서부터 처리하면 인덱스 밀림의 영향을 받지 않기 때문이다.

 2. 실행 과정
    1. num = 9 (인덱스 9, 값 10)
        - my_list[9]는 10으로 짝수이다. 따라서 pop(9)을 호출하여 10을 제거한다.
        - 리스트 상태: [1, 2, 3, 4, 5, 6, 7, 8, 9]
        - new_list에 [10] 추가.

    2. num = 8 (인덱스 8, 값 9)
        - my_list[8]은 9로 홀수이다. 따라서 건너뛰고 다음으로 이동.

    3. num = 7 (인덱스 7, 값 8)
        - my_list[7]은 8로 짝수이다. pop(7)을 호출하여 8을 제거한다.
        - 리스트 상태: [1, 2, 3, 4, 5, 6, 7, 9]
        - new_list에 [10, 8] 추가.

    4. num = 5 (인덱스 5, 값 6)
        - my_list[5]는 6으로 짝수이다. pop(5)을 호출하여 6을 제거한다.
        - 리스트 상태: [1, 2, 3, 4, 5, 7, 9]
        - new_list에 [10, 8, 6] 추가.
    5. num = 4 (인덱스 4, 값 5)
        - my_list[4]은 5로 홀수이다. 따라서 건너뛰고 다음으로 이동.
    6. 7. 8. 9. 10. 이런 방식으로 진행

3. 최종 상태
- new_list: [10, 8, 6, 4, 2]
- new_list.sort()을 통해 오름차순으로 정렬하면: [2, 4, 6, 8, 10]

4. 결론
 - 역순으로 순회하면서 pop을 사용하면, 리스트에서 요소를 제거한 후 다음 요소들이 밀리지 않기 때문에 순차적으로 처리할 수 있다. 순방향으로 순회할 경우, pop을 사용할 때마다 인덱스가 변경되어 예상하지 못한 요소를 건너뛰는 문제가 발생할 수 있다.